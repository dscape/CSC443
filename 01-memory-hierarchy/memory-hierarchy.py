import subprocess
from os import path
import numpy as np
import matplotlib.pyplot as plt

# Constant defining the size of the file generated by create_random_file.
FILE_SIZE = 104857600

# Name of the file to which the output of create_random_file will be written.
RANDOM_FILE = "noise"

def runcmd(args):
    """
    Helper function that executes the given command and returns the stdout
    contents.
    """
    proc = subprocess.Popen(map(str, args), stdout=subprocess.PIPE)
    return proc.stdout.read()

## Execute

# Absolute paths to the two executables.
get_histogram      = path.abspath("get_histogram")
create_random_file = path.abspath("create_random_file")

write_data = []
read_data  = []

for exp in xrange(10, 26):
    block_size = 2 ** exp
    
    # Execute create_random_file to test write speeds.
    args = [create_random_file, RANDOM_FILE, FILE_SIZE, block_size]
    (w_blk, w_time_taken) = runcmd(args).split()
    write_data.append( (int(w_blk), int(w_time_taken)) )
    
    # Execute get_histogram to test read speeds.
    args = [get_histogram, RANDOM_FILE, block_size]
    (r_blk, r_time_taken) = runcmd(args).split()
    read_data.append( (int(r_blk), int(r_time_taken)) )
    
    print "Block: 2^%d bytes; Time (W): %s msecs; Time (R): %s msecs" % (
            exp, w_time_taken, r_time_taken)

## Plot

(w_xs, w_ys) = zip(*write_data)
(r_xs, r_ys) = zip( *read_data)

(w_minx, w_miny) = min(write_data, key=lambda (x, y): y)
(r_minx, r_miny) = min( read_data, key=lambda (x, y): y)

fig = plt.gcf()
fig.clear()
fig.suptitle("Total number of bytes: %d" % FILE_SIZE)

# Plot write data
w_plt = fig.add_subplot(111)
w_line = w_plt.semilogx(w_xs, w_ys, 'b.-', label='Read', basex=2)
w_plt.set_xlabel("Block size")
w_plt.set_ylabel("Write time (in milliseconds)")
w_plt.axvline(w_minx, color='r', linestyle=':', ymin=0.05)
w_plt.annotate("$2^{%d}$" % np.log2(w_minx), xy=(w_minx, w_plt.get_ylim()[0]),
        xytext=(0, 3), textcoords='offset points', verticalalignment='bottom',
        horizontalalignment='center', fontsize=15)

# Plot read data
r_plt = w_plt.twinx()
r_line = r_plt.semilogx(r_xs, r_ys, 'g.-', label='Write', basex=2)
r_plt.set_ylabel("Read time (in milliseconds)")
r_plt.axvline(r_minx, color='r', linestyle=':', ymax=0.95)
r_plt.annotate('$2^{%d}$' % np.log2(r_minx), xy=(r_minx, r_plt.get_ylim()[1]),
        xytext=(0, -3), textcoords='offset points', verticalalignment='top',
        fontsize=15, horizontalalignment='center')

# Add legend
fig.legend(tuple(w_line + r_line), ('Write', 'Read'))

# Save the figure
fig.savefig('memory-hierarchy.pdf')
